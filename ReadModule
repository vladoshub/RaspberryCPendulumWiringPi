#include <wiringPi.h>
#include <stdio.h>
#include <math.h>
#include <sys/time.h>
#include <malloc.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdbool.h>
#define countElements 20000

typedef enum {
    Ready,
    Write,
    Pause
} workType;

typedef enum {
    WaitingUser,
    Run,
    Error
} programState;

bool StateA, StateB;
bool Mah=true;
double Time[countElements];//массив с временем
int Coord[countElements];//массив с координатами
long Coordinate = 0;//координата
int count=0;//счетчик в массиве
struct timeval start;//время от запуска всей программы(не нашел другой метод,поэтому просто будем вычитать это значение из времени полученного при срабатывания прерывания)
struct timeval timevals[countElements];//массив структуры миллисекунд
int stopReadFromPipe=100000;//остановка на 1/10 сек для считывания с pipe
int stopReadFromSensor=100;//остановка на 100микросек для проверки маха маятика
int countBuf=10;//буфер чтения
char readbuffer[countBuf];
char Channel='o';
int mahMax=9995;
int pendPoint=0;//точка начала отчета
int offsetPointMax=0;//максимально возможное смещение в сторону противоположную перемещению маятника при измерении маха
enum workType typeWork=Ready;
enum programState state=WaitingUser; 

void timevalToDouble(){//перевод из формата timaval в double
for(int i=0;i<count;i++)
Time[i]=(double)(timevals[i].tv_usec - start.tv_usec) / 1000000 + (double)(timevals[i].tv_sec - start.tv_sec);//вычисляем разность времени для каждого тика
}

void Clear(){

count=0;
}

void getCurrentCoordinate(char *readbuffer,int *fd){ //получить текующую координату
int nbytes;
char outC[16];
snprintf(outC, 16, "%d", Coordinate);
write(fd[1], outC,(strlen(outC)+1));//пишем координату Python
}

void getDataFromSensor(int *fd){ 
if(count<1){
return;
}
timevalToDouble();
char outT[20],outC[16];
write(fd[1], count, (strlen(count)+1));//передаем размерность массива
for(int i=0;i<count;i++){
snprintf(outT, 20, "%f", Time[i]);//преобразуем в char время
snprintf(outC, 16, "%d", Coord[i]);//преобразуем в char координату
write(fd[1], outT, (strlen(outT)+1));//отсылаем время 1 тика
write(fd[1], outC,(strlen(outC)+1));//отсылаем координату 1 тика
}
Clear();
}

void readFromPipe(int *fd){
read(fd[0], readbuffer, sizeof(readbuffer));
if(readbuffer== '0'){//получение текущей координаты
    getCurrentCoordinate(readbuffer,fd);
}
if(readbuffer== '1'){//Запись в буфер маха
    Clear();
    gettimeofday(&start, NULL);
    typeWork=Ready;
    state=Run;
}
if(readbuffer== '2'){//Отдать данные в систему
    typeWork=Pause;
    getDataFromSensor(fd);
    typeWork=Ready;
}
if(readbuffer== '3')exit(0);//Выход
if(readbuffer== '4'){//Изменение чувствительнсоти
    offsetPoint=0;//здесь данные с буфера будут
    offsetPointMax=0;
}
if(readbuffer== '5'){//Сброс
    Clear();
    Coordinate=0;
    Channel='o';
}
else{getCurrentCoordinate(readbuffer,fd);}
usleep(stopReadFromPipe);// сон после выполнения операция на пол сек
readFromPipe(fd);//заного читаем

}

void ISR_A()//прерывание по каналу A
{
switch(typeWork){//смотрим текущее состояние работы
    
case Ready ://ожидание смещения для записи
    StateA = !StateA;
    if (State_B != State_A){
    Coordinate++;
    if(abs(Coordinate)>pendPoint)//проверка на смещение относительно начала
    typeWork=Write;//переход в режим записи
    Channel='+';//учет направления движения
    }
    else {
    Coordinate--;
        if(abs(Coordinate)>pendPoint){//переход в режим записи
        typeWork=Write;
        Channel='-';
        }//учет направления движения
    }
break;

case Write ://запись данных в память
    StateA = !StateA;
    if (State_B != State_A){//движение в одну сторону
    if(Channel=='+'){//если текущее направление движения совпадает с начальным-пишем
    Coordinate++;
    Coord[count]=abs(Coordinate);//коордианта
    gettimeofday(&timevals[count], NULL);//время
    count++;//ячейка массива
    Mah=true;//снимаем фиксацию с offsetPointMax
    }
    else{//если пошли обратно
    if(Mah){//если первое отклонение назад
    offsetPointMax=abs(Coordinate)-offsetPointMax;//записываем начальную коордианту откуда пошло движение назад
    Mah=false;//фиксируем коордианту откуда пошло движение назад
    }
        if(abs(Coordinate)<=offsetPointMax){//смотрим на сколько сместилось
        typeWork=Pause;//если да перестаем писать
        Coordinate++;
        }
        else{
         Coordinate++;// иначеп просто фикс изменяем коордианту
        }

    
     }
    }
    else {//движение в противоположную сторону
     if(Channel=='-'){//если текущее направление движения совпадает с начальным-пишем
    Coordinate--;
    Coord[count]=abs(Coordinate;)
    gettimeofday(&timevals[count], NULL);
    count++;
      Mah=true;
    }
    else{//иначе пошли обратно
    if(Mah){//если первое или последовательное отклонение назад
    offsetPointMax=abs(Coordinate)-offsetPointMax;
    Mah=false;
    }
        if(abs(Coordinate)<=offsetPointMax){
        typeWork=Pause;
        Coordinate++;
        }
        else{
         Coordinate++;
        }

    
     }
    
    }
}
break;

case Pause://просто отслеживаем маятик без записи в память
 StateB = !StateB;
    if (State_B == State_A)
    Coordinate++;
    else {
    Coordinate--;
    }
break;

void ISR_B()
{
switch(typeWork){

case Ready ://ожидание сдвига маятника на n тиков 
    StateB = !StateB;
    if (State_B == State_A){
    Coordinate++;
    if(abs(Coordinate)>pendPoint)//переход в режим записи
    typeWork=Write;
    Channel='+';//учет направления движения
    }
    else {
    Coordinate--;
        if(abs(Coordinate)>pendPoint)//переход в режим записи
        typeWork=Write;
        Channel='-';//учет направления движения
    }
break;

case Write ://запись маха 
    StateB = !StateB;
    if (State_B == State_A){//движение в одну сторону
    if(Channel=='+'){//если текущее направление движения совпадает с начальным-пишем
    Coordinate++;
    Coord[count]=abs(Coordinate);
    gettimeofday(&timevals[count], NULL);
    count++;
    Mah=true;
    }
    else{//иначе пошли обратно
    if(Mah){//если первое или последовательное отклонение назад
    offsetPointMax=abs(Coordinate)-offsetPointMax;
    Mah=false;
    }
        if(abs(Coordinate)<=offsetPointMax){
        typeWork=Pause;
        Coordinate++;
        }
        else{
         Coordinate++;
        }

    
     }
    }
    else {//движение в противоположную сторону
     if(Channel=='-'){//если текущее направление движения совпадает с начальным-пишем
    Coordinate--;
    Coord[count]=abs(Coordinate);
    gettimeofday(&timevals[count], NULL);
    count++;
      Mah=true;
    }
    else{//иначе пошли обратно
    if(Mah){//если первое или последовательное отклонение назад
    offsetPointMax=abs(Coordinate)-offsetPointMax;
    Mah=false;
    }
        if(abs(Coordinate)<=offsetPointMax){
        typeWork=Pause;
        Coordinate++;
        }
        else{
         Coordinate++;
        }

    
     }
    
    }
  

break;

case Pause ://просто отслеживаем маятик без записи в память
 StateB = !StateB;
    if (State_B == State_A)
    Coordinate++;
    else {
    Coordinate--;
    }
break;
}


}


int main()
{
readbuffer='0';//ожидание
int fd[2];
pipe(fd);
const int ChannelA = 23;
const int ChannelB = 24;
wiringPiSetupGpio (); //BCM mode
pinMode (ChannelA, INPUT);
pinMode(ChannelB, INPUT);
StateA = digitalRead(ChannelA);
StateB = digitalRead(ChannelB);
wiringPiISR(ChannelA, INT_EDGE_BOTH, ISR_A);
wiringPiISR(ChannelB, INT_EDGE_BOTH, ISR_B);
readFromPipe(fd);
}
